System wis

// WIS
Dispatch start_robot : start_robot(X)

// OPROBOT
Dispatch waiting : waiting(X)

// WASTE STORAGE
Dispatch waste_in : waste_in(X)
Dispatch waste_qty : waste_qty(X)
Dispatch get_waste : get_waste(X)

// INCINERATOR
Dispatch turn_on : turn_on(X)
Dispatch burn_in : burn_in(X)
Dispatch burn_start : burn_start(X)
Dispatch burn_end : burn_end(X)
Dispatch get_ash : get_ash(X)

// ASH STORAGE
Dispatch deposit_ash : deposit_ash(X)
Request empty_ash : empty_ash(X)
Reply ashes_taken : ashes_taken(LEVEL) for empty_ash

// BASIC ROBOT
Request moverobot    :  moverobot(TARGETX, TARGETY)
Reply moverobotdone  :  moverobotok(ARG)
Reply moverobotfailed:  moverobotfailed(PLANDONE, PLANTODO)

Context ctx_wis ip [host="localhost" port=8014] 
Context ctx_basic_robot  ip  [host="localhost" port=8020]

ExternalQActor basic_robot context ctx_basic_robot
ExternalQActor waste_storage context ctx_wis
ExternalQActor ash_storage context ctx_wis
ExternalQActor incinerator context ctx_wis
ExternalQActor wis context ctx_wis

QActor oprobot context ctx_wis  {
	[# 
		import "wis.util"; 
		var RP: boolean = false;
		var ASH: boolean = false;
		var T: String = ""; 
		var TX,TY; 	
	#]
	
	State s0 initial {
		println("$name STARTS") color green 
		solve(consult("sysRules.pl"))
		solve(consult("pointPicker.pl"))
	}
	
	State waiting {
		forward wis -m waiting:waiting(1)
	}
	
	Transition t0 whenMsg start_robot -> to_ws
	
	State to_ws {
		[# T = Position.WASTEIN.name; #]
		solve(getPoint(T,X,Y))
		ifSolved { [# TX = getCurSol(X); TY = getCurSol(Y); #]}
			
		request basic_robot -m moverobot:moverobot($TX,$TY)
	}
	
	Transition t1 whenReply moverobotdone -> withdraw_ws
				  whenReply moverobotfailed -> to_ws
				  
    State withdraw_ws {
    	forward waste_storage -m get_waste:get_waste(1)
    	[# RP = True; #]
    }
    
    State to_incinerator {
    	[# T = Position.BURNIN.name; #]
		solve(getPoint(T,X,Y))
		ifSolved { [# TX = getCurSol(X); TY = getCurSol(Y); #]}
		
		request basic_robot -m moverobot:moverobot($TX,$TY)
    }
    
    Transition t2 whenReply moverobotdone -> ask_to_burn
				  whenReply moverobotfailed -> to_incinerator
				  
	
	State ask_to_burn {
		forward incinerator -m burn_in:burn_in(1)
		[# RP = false #]
	}
	
	State go_wait_home {
		[# T = Position.HOME.name; #]
		solve(getPoint(T,X,Y))
		ifSolved { [# TX = getCurSol(X); TY = getCurSol(Y); #]}
		
		request basic_robot -m moverobot:moverobot($TX,$TY)
	}
    
    Transition t3 whenReply moverobotdone -> wait_for_burn
				  whenReply moverobotfailed -> go_wait_home
				  
	State wait_for_burn {
	}
	
	Transition t4 whenMsg burn_end -> to_incinerator_burned
	
	State to_incinerator_burned {
		[# T = Position.BURNOUT.name; #]
		solve(getPoint(T,X,Y))
		ifSolved { [# TX = getCurSol(X); TY = getCurSol(Y); #]}
		
		request basic_robot -m moverobot:moverobot($TX,$TY)
	}
	
	Transition t5 whenReply moverobotdone -> get_ash
				  whenReply moverobotfailed -> to_incinerator_burned
	
	State get_ash {
		forward incinerator -m get_ash:get_ash(1)
		[# ASH = true #]
	}
	
	State to_ash_storage {
		[# T = Position.ASHOUT.name; #]
		solve(getPoint(T,X,Y))
		ifSolved { [# TX = getCurSol(X); TY = getCurSol(Y); #]}
	
		request basic_robot -m moverobot:moverobot($TX,$TY)
	}
	
	
	Transition t6 whenReply moverobotdone -> ask_as
				  whenReply moverobotfailed -> to_ash_storage
	
	State ask_as {
		forward ash_storage -m deposit_ash:deposit_ash(1)
		[# ASH = false #]
	}
	
	State go_back_home {
		[# T = Position.HOME.name; #]
		solve(getPoint(T,X,Y))
		ifSolved { [# TX = getCurSol(X); TY = getCurSol(Y); #]}
		
		request basic_robot -m moverobot:moverobot($TX,$TY)
	}
	
	Transition t7 whenReply moverobotdone -> waiting
				  whenReply moverobotfailed -> go_back_home
}