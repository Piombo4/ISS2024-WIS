<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>

<head>
	<!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/foundation-sites@6.7.4/dist/css/foundation.min.css"
		crossorigin="anonymous">
	<script src="https://cdn.jsdelivr.net/npm/foundation-sites@6.7.4/dist/js/foundation.min.js"
		crossorigin="anonymous"></script>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" type="text/css" href="./commons/resources/styles/templateISS.css">
	<link rel="stylesheet" type="text/css" href="./commons/resources/styles/main.css">
	<link rel="stylesheet" type="text/css" href="./commons/resources/styles/navbar.css">
	<link rel="stylesheet" type="text/css" href="./commons/resources/styles/table.css">
	<link rel="stylesheet" type="text/css" href="./commons/resources/styles/code.css">

	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap"
		rel="stylesheet">

	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Rubik:ital,wght@0,300..900;1,300..900&display=swap"
		rel="stylesheet">

	<!-- <script type="text/javascript" src="./commons/resources/scripts/myScripts.js"></script> -->
	<style type="text/css">
		body {
			margin: auto;
			max-width: 1300px;
			font-family: "Open Sans", sans-serif;
			font-optical-sizing: auto;
		}

		body {
			font-family: "Rubik" !important;
			font-optical-sizing: auto;
		}

		P {}

		;

		a,
		a:visited,
		a:active,
		a:link,
		a:hover {
			text-decoration: underline;
			color: #545454;
			background-color: transparent;
			font-size: 93%;
		}

		a:hover {
			background-color: #cccccc;
		}


		hr {
			clear: both;
			height: 1px;
			color: #242424;
			background-color: transparent;
		}

		h1,
		h2,
		h3 {
			color: #242424;
			clear: left;
			font: 100% Tahoma, Helvetica, Arial, sans-serif;
			margin-top: 1em;
			padding-top: 0.5em;
			border-radius: 10px;
			padding: 5px;
		}

		top {
			width: 100%;
		}


		#i {
			color: #ff1010;
		}

		tt {
			font-family: "Arial";
			font-size: 90%;
			color: #006600;
		}

		em {
			font-family: "Arial";
			font-size: 80%;
			font-weight: bold;
			border-style: solid;
			border-color: #abe876;
			color: #1632cc;
		}

		bc {
			font-family: "Arial";
			font-size: 90%;
			font-weight: bold;
			color: #990000;
			background-color: #fcf8c7;
		}

		ks {
			font-family: "Arial";
			font-weight: bold;
			color: #0000CD;
			font-size: 90%;
		}

		kc {
			font-family: "Arial";
			font-weight: bold;
			color: #008000;
			font-size: 90%;
		}

		todo {
			background-color: #FFFF00 !important
		}

		todo:before {
			content: "TODO:";
			font-weight: bold;
		}

		red {
			color: #fa2929;
			font-weight: bold;
		}

		pre {
			font-family: "Consolas";
			font-size: 85%;
			background-color: #f5f5f5;
			border: 1.5px solid silver;
			padding: 5px;
		}

		m {
			font-family: "Helvetica";
			line-height: 100%;
			font-size: 75%;
		}

		div.body {

			font-size: 18px;
		}

		k {
			color: #990000;
			font-weight: bold;
			font-size: 90%;
		}

		h1 {
			font-size: 150%;
			background-color: #b2c0ff;
			padding: 10px;
		}

		h2 {
			background-color: #9ed8ff;
			font-size: 130%;
		}

		h3 {
			background-color: #e6ccff;
			font-size: 100%;
		}

		h4 {
			background-color: #ccffcc;
			font-size: 100%;
			width: 95%;
			border-radius: 5px;
			padding: 2px;
		}

		h5 {
			background-color: #d5ffb0;
			font-size: 100%;

		}

		div.req {
			background-color: #d9ffb3;
			font-size: 18px;
			width: 700px;
			border: 3px solid green;
			padding: 15px;
			margin: 10px;
		}

		div.remark {
			background-color: #E3F2FD;
			border: 1.5px solid #d5f2ed;
			padding: 15px;
			margin: 10px;
			border-radius: 15px;
		}

		table,
		th,
		td {
			border: 1px solid black;
			border-collapse: collapse;
			text-align: center;
		}

		td.disp {
			background-color: #7b7bff;
			color: white;
		}

		td.update {
			background-color: rgb(151, 113, 254);
			color: white;
		}

		td.event {
			background-color: rgb(47, 255, 106);
			color: #242424;
		}

		ol,
		ul,
		li {
			margin: 0;
			margin-left: 25px;
			padding: 0;
			padding-bottom: 5px;
		}

		table,
		th,
		td {
			border: 1px solid black;
		}

		table {
			table-layout: auto !important;
		}

		img {
			border: 1.5px solid #d5f2ed
		}

		a,
		a:visited,
		a:active,
		a:link,
		a:hover {
			text-decoration: underline;
			color: #545454;
			background-color: transparent;
		}

		div.wrapdesc {
			width: 90%;
			margin: auto;
		}

		msg {
			color: #ff1010;
		}

		div.imagedesc {
			width: 85%;
			margin: auto;
		}
	</style>



</head>






<title>Sprint 1</title>
</head>

<!--
	<body onload="loadNav();">
		<div id="openButton" class="openButton" onclick="openNav(true)">&#9776; Menu</div>
		<div id="sidenav" class="sidenav">
			<a class="closeButton" href="javascript:void(0)" onclick="closeNav(true)">&times;</a>
			<a href=".README.html">ReadMe</a>
			<a class="sprint" href="../../../Sprint0/Codice/userDocs/Cold%20Storage%20Service%20-%20Natali%20V3.html">Sprint0</a>
			<a class="sprint" href="../../../Sprint1.0/Codice/userDocs/Sprint%201.0%20-%20V3.html">Sprint1.0</a>
			<a class="sprint" href="../../../Sprint1.1/Codice/userDocs/Sprint%201.1%20-%20V3.html">Sprint1.1</a>
			<a id="currentSprint" class="sprint" href="#">&#8211;&#8212; Sprint2 &#8212;&#8211;</a>
			<div class="sidenavSection">
				<a href="#Goal Sprint 2">Goal Sprint 2</a>
				<a href="#Requisiti">Requisiti</a>
				<a href="#Analisi dei Requisiti">Analisi dei Requisiti</a>
				<a href="#Analisi del Problema">Analisi del Problema</a>
				<a href="#Test Plan">Test Plan</a>
				<a href="#Progettazione">Progettazione</a>
				<a href="#Deployment">Deployment</a>
			</div>
			<p class="separator">&mdash;&mdash;&mdash;&ndash;&ndash;&mdash;&mdash;&mdash;</p>
			<a class="sprint" href="../../../Sprint3/Codice/userDoc/Sprint%203.html">Sprint3</a>
			<bottom-spacer/>
		</div>
-->

<body background="">
	<div id="top">
		<h1>Waste Incinerator Service - ISS 2024 <font size="5"></font>
		</h1>
	</div>

	<div class="body">
		<h2>Analisi del problema</h2>
		<h3>Rappresentazione dell'area di servizio</h3>
		La mappa della stanza può essere rappresentata tramite un piano cartesiano. In questo modo possiamo formalizzare
		il concetto di posizione, intesa come una coppia di coordinate cartesiane.
		<br>
		Per semplicità, <b>HOME</b> è l'origine(0,0).<br>
		La stanza viene quindi suddivisa in una griglia, dove ciascuna cella è un quadrato di lato D, ovvero il diametro
		dell'<b>OpRobot</b>.
		Nella stanza sono presenti diverse posizioni rilevanti:
		<ul>
			<li>
				<b>HOME</b>
			</li>
			<li>
				<b>WASTEIN</b>
			</li>
			<li>
				<b>BURNIN</b>
			</li>
			<li>
				<b>BURNOUT</b>
			</li>
			<li>
				<b>ASHOUT</b>
			</li>
		</ul>

		<todo> inserire immagine</todo><br>
		Ciascuna di esse sarà rappresentata da una o più celle all'interno della mappa, che decideremo dopo aver creato
		la configurazione della mappa.<br>
		Per creare la mappa, utilizzeremo un software fornito dal cliente: <b>MapBuilder24</b> (da mettere link) che
		andrà a generare un file di configurazione che rappresenterà la stanza e i suoi ostacoli.<br><br>
		<todo> inserire code block mappa: Map.text</todo><br>
		Per rappresentare le <b>posizioni rilevanti</b> sulla mappa, verrà utilizzata una <b>base di conoscenza
			prolog</b> contenente un insieme di triple: <b>(x,y,NOME_POSIZIONE)</b>.<br>
		Questo va ad aggiungere un nuovo requisito, ovvero una nuova funzionalità che dato il nome di una posizione ne
		restituisca le coordinate.<br>

		In questo modo si va ad evitare di assegnare ad un solo attore tutta l'informazione relativa alle posizioni,
		dando la possibilità
		a tutti i componenti di accedervi (sia il <b>WIS</b> che <b>OpRobot</b> necessitano di queste
		informazioni).
		<br>
		<h3>WIS</h3>
		Il <b>WIS</b> è gia stato identificato come attore nella fase precedente e assume il ruolo di
		"controllore/gestore" del sistema che fa da coordinatore delle comunicazioni.

		<h4>GUI</h4>
		La GUI viene modellata come una Facade, dato che abbiamo bisogno di un'interfaccia grafica che mostri all'utente
		le informazioni aggiornate relative allo stato del sistema.<br>
		Si è deciso di utilizzare una Facade perchè il linguaggio QAK (da noi scelto per questo progetto) possiede le
		capacità espressive per dichiarare e comunicare con Facade ad alto livello
		senza preocupparci del livello di implemetazione sottostante.

		<h3>OpRobot</h3>
		Il cliente mette a disposizione un <b>DDR Robot</b>, l'attuatore fisico del comportamento dell'<b>OpRobot</b>
		che è un entità astratta che incapsula la logica del robot, e il suo sw di controllo (<b>BasicRobot</b>).
		<br><br>

		L'<b>OpRobot</b> sarà rappresentato da un attore, poichè il sw fornito dal cliente, che controlla il DDR,
		comunica solamente tramite scambio di messaggi. Di conseguenza è necessario modellare <b>OpRobot</b> affinché
		sia in grado di utilizzare <b>l'interfaccia</b> offerta da <b>BasicRobot</b> per comandare il robot fisico.
		<br>
		In particolare, essa verrà utilizzata per spostare il robot da una posizione rilevante ad un'altra (
		informazione ottenuta tramite la base di conoscenza ).
		Il componente di cui si farà uso è il <b>Planner24</b> (mettere link), che permette di costruire dinamicamente
		una
		sequenza di mosse attraverso le quali il robot può muoversi dalla posizione corrente ad un’altra posizione sulla
		mappa della stanza costruita in precedenza.
		<br>
		<hr>
		Per rappresentare lo spostamento di 1 RP da una parte all'altra dell'area di servizio, <b>OpRobot</b> mantiene
		tramite una variabile l'informazione relativa al possedimento o meno di un pacchetto in un determinato momento
		(un variabile booleana).
		<br>
		<br>
		Inoltre, deve comunicare al WIS due informazioni: la sua <b>posizione attuale</b> ed il <b>lavoro</b>
		che sta svolgendo. La prima tramite coordinate cartesiane, mentre la seconda viene rappresentata da vari stati
		in cui il robot può trovarsi:
		<ul>
			<li>
				<b>WAITING</b>: il robot è nella home aspettando che il WIS gli dia il via

			</li>
			<li>
				<b>MOVE_TO_WS</b>

			</li>
			<li>
				<b>WITHDRAW_RP_FROM_WS</b>

			</li>
			<li>
				<b>MOVE_TO_INCINERATOR</b>

			</li>
			<li>
				<b>DEPOSIT_RP_INTO_INCINERATOR</b>

			</li>
			<li>
				<b>MOVING_TO_HOME</b>

			</li>
			<li>
				<b>WAITING_FOR_BURN</b>

			</li>
			<li>
				<b>WITHDRAW_ASHES_FROM_INCINERATOR</b>

			</li>
			<li>
				<b>MOVING_TO_AS</b>

			</li>
			<li>
				<b>DEPOSIT_ASHES_INTO_AS</b>

			</li>
			<li>
				<b>BACK_HOME</b>

			</li>
		</ul>
		<h3>Waste Storage</h3>
		Il <b>Waste Storage</b> viene modellato come un attore perchè è un'entità che deve essere sempre attiva per
		poter ricevere messaggi e rispondere di conseguenza.
		Al suo interno contiene una <b>Scale</b> modellata come un POJO (una variabile), il cui compito è quello tenere
		traccia del peso degli RP nel <b>Waste Storage</b>.
		Interagisce sia con l'entità esterna sia con l'OpRobot che rispettivamente depositano e prevelevano un RP alla
		volta.
		<br>

		<h3>Ash Storage</h3>
		L'<b>Ash Storage</b> viene modellato come attore poichè è un'entità che scambia messaggi con il robot e con
		l'entità esterna quando si richiede il prelievo delle ceneri. <br>
		Deve mantenere al suo interno l'informazione relativa al livello di ceneri depositate (informazione che sarà
		necessaria al Sonar), viene utilizzata una variabile intera a questo scopo.<br>
		Una entità esterna in istanti di tempo non precisati può prelevare tutta la cenere dall'ash storage svuotandolo
		completamente.



		<h3>Monitoring Device</h3>
		Come accennato nella fase precedente, il monitoring device, essendo fisicamente su un Raspberry PI, gira in un
		nodo (contesto) separato ed è formato da due componenti:
		<h4>Led</h4>
		Il Led è un attore che può trovarsi in uno di 3 stati (in base alle informazioni ricevute dal WIS)
		<ul>
			<li>
				<b>ON</b>: quando l’Incinerator sta bruciando un RP

			</li>
			<li>
				<b>OFF</b>: quando l’Incinerator non è in funzione

			</li>
			<li>
				<b>Blink</b>: quando l’Ash Storage è pieno o vuoto

			</li>
		</ul>


		<h4>Sonar</h4>
		Il Sonar è un attore il cui unico compito è misurare il livello delle ceneri nell'<b>Ash Storage</b> e
		comunicare quanto rilvevato al <b>WIS</b>. <br>

		<h3>Contesti</h3>
		I 3 nuovi attori identificati nell'analisi del problema sono stati inseriti in <b>ctx_wis</b> poichè non sono
		stati trovati motivi per metterli in contesti separati.
		La gui essendo una facade, è per definizione assegnata ad un contesto separato.
		<ul>
			<li>
				<b>ctx_wis</b>: <b>WIS</b> + <b>Incinerator</b> + <red>OpRobot</red> + <red>Waste Storage</red> + <red>
					Ash Storage</red>
			</li>
			<li>
				<b>ctx_basic_robot</b>: il <b>Basic Robot</b> per sua definizione è già presente in un contesto separato
			</li>
			<li>
				<b>ctx_monitoringdevice</b>: <b>Led</b> + <b>Sonar</b>
			</li>
			<red>
				<li>
					<b>ctx_gui</b>: contesto in cui sarà eseguita il facade.
				</li>
			</red>

		</ul>
		In <red>rosso</red> gli attori e contesti aggiunti in questa fase.
		<h3>Interazioni/Messaggi</h3>

		<table>
			<tr>
				<th>Nome</th>
				<th>Tipo</th>
				<th>Mittente</th>
				<th>Destinatario</th>
			</tr>

			<tr>
				<td>START_ROBOT</td>
				<td class="disp">Dispatch</td>
				<td>WIS</td>
				<td>OpRobot</td>
			</tr>
			<tr>
				<td colspan="4">Inviato quando il robot è in stato WAITING. Indica che esso può iniziare a muoversi
					verso WASTEIN (il WIS ha verificato che il Waste Storage non è vuoto, l’Ash Storage non è pieno e
					l’Incinerator non è in burning phase).</td>
			</tr>
			<tr>
				<td>UPDATE_GUI</td>
				<td class="disp">Dispatch</td>
				<td>WIS</td>
				<td>SSGUI</td>
			</tr>
			<tr>
				<td colspan="4">Inviato ogni volta che la GUI deve essere aggiornata. Contiene diverse informazioni:
					(NRP_WS, QTY_ASH, ISBURNING, ROBOT_STATUS) </td>
			</tr>
			<tr>
				<td>ROBOT_STATUS</td>
				<td class="update">UpdateResource</td>
				<td>OpRobot</td>
				<td>WIS</td>
			</tr>
			<tr>
				<td colspan="4">Inviato ogni volta che il robot cambia posizione e lavoro (informazione che deve essere
					mantenuta all'interno dell'OpRobot), formato dai seguenti campi: (x,y,JOB)</td>
			</tr>
			<tr>
				<td>WASTE_QTY</td>
				<td class="update">UpdateResource</td>
				<td>Waste Storage</td>
				<td>WIS</td>
			</tr>
			<tr>
				<td colspan="4">Indica il peso in KG degli RP contenuti nel Waste Storage.</td>
			</tr>
			<tr>
				<td>ASH_QTY</td>
				<td class="update">UpdateResource</td>
				<td>Ash Storage</td>
				<td>WIS</td>
			</tr>
			<tr>
				<td colspan="4">Indica il livello di ceneri nell'Ash Storage. Tale valore viene misurato dal sonar del
					monitoring device.</td>
			</tr>
			<tr>
				<td>BURNING</td>
				<td class="disp">Dispatch</td>
				<td>Incinerator</td>
				<td>WIS</td>
			</tr>
			<tr>
				<td colspan="4">Indica al WIS che l'Incinerator è in burning phase. </td>
			</tr>
			<tr>
				<td>BURN_OUT</td>
				<td class="disp">Dispatch</td>
				<td>Incinerator</td>
				<td>WIS + OpRobot</td>
			</tr>
			<tr>
				<td colspan="4">Indica che l'Incinerator ha finito di bruciare 1 RP, ovvero è passato BTIME
					dall'inserimento del pacchetto ed è quindi finita la burning phase.</td>
			</tr>
			<tr>
				<td>WASTE_IN</td>
				<td class="event">Evento</td>
				<td>Entità esterna</td>
				<td>Waste Storage</td>
			</tr>
			<tr>
				<td colspan="4">Si verifica quando l'entità esterna vuole depositare 1 RP all'interno del Waste Storage.
					Provoca l'incremento di 1 RP della capacità di quest'ultimo (+50 KG sulla Scale).</td>
			</tr>
			<tr>
				<td>GET_WASTE</td>
				<td class="disp">Dispatch</td>
				<td>OpRobot</td>
				<td>Waste Storage</td>
			</tr>
			<tr>
				<td colspan="4">Inviato per rappresentare il prelievo di 1 RP dal Waste Storage quando il robot è
					posizionato sulla porta WASTE_IN. Provoca il decremento di 1 RP della capacità di quest'ultimo (-50
					KG sulla Scale). La variabile booleana dentro il robot viene messa a true. </td>
			</tr>
			<tr>
				<td>TURN_ON </td>
				<td class="event">Evento</td>
				<td>Entità esterna</td>
				<td>Incinerator</td>
			</tr>
			<tr>
				<td colspan="4">Indica l'accensione dell'Incinerator. </td>
			</tr>
			<tr>
				<td>BURN_IN </td>
				<td c lass="disp">Dispatch</td>
				<td>OpRobot</td>
				<td>Incinerator</td>
			</tr>
			<tr>
				<td colspan="4">Inviato per rappresentare il deposito di 1 RP nell'Incinerator quando il robot si trova
					in BURNIN. Alla ricezione del messaggio, l’Incinerator entra in burning phase (e manda il messaggio
					BURNING al WIS). </td>
			</tr>
			<tr>
				<td>ASH_OUT </td>
				<td class="disp">Dispatch</td>
				<td>OpRobot</td>
				<td>Ash Storage</td>
			</tr>
			<tr>
				<td colspan="4"> Inviato per rappresentare il deposito della cenere corrispondente ad 1 RP
					nell'AshStorage. Il robot si trova in posizione ASHOUT (il sonar si aggiornerà di conseguenza). La
					variabile booleana dentro il robot viene messa a false.
				</td>

			</tr>
			<tr>
				<td>GET_ASH </td>
				<td class="event">Evento</td>
				<td>Entità esterna</td>
				<td>Ash Storage</td>
			</tr>
			<tr>
				<td colspan="4">Si verifica quando l'entità esterna rimuove la cenere dall'Ash Storage. Provoca
					l'aggiornamento del valore misurato dal sonar. </td>
			</tr>
			<tr>
				<td>LED_ON </td>
				<td class="disp">Dispatch</td>
				<td>WIS</td>
				<td>LED</td>
			</tr>
			<tr>
				<td colspan="4">Inviato per indicare che l'Incinerator sta bruciando 1 RP, ovvero è in burning phase.
				</td>
			</tr>
			<tr>
				<td>LED_OFF </td>
				<td class="disp">Dispatch</td>
				<td>WIS</td>
				<td>LED</td>
			</tr>
			<tr>
				<td colspan="4">Inviato per indicare che l'Incinerator non è in un burning phase.</td>
			</tr>
			<tr>
				<td>BLINK</td>
				<td class="disp">Dispatch</td>
				<td>WIS</td>
				<td>LED</td>
			</tr>
			<tr>
				<td colspan="4">Inviato per indicare che l'Ash Storage è pieno (quando il valore misurato dal sonar è
					minore di DLIMIT) oppure è vuoto (in questo caso, quando il
					valore misurato dal sonar è uguale ad un valore DMAX allora l'Ash Storage è vuoto).</td>
			</tr>
		</table>

		<h3>Architettura Logica</h3>
		<img src="../sprint0_architettura_with_msgarch.png" alt="">
		<h3>Test Plans</h3>
		<table>
			<tr>
				<th>
					Test
				</th>
				<th>
					Attori
				</th>
				<th>
					Descrizione
				</th>
				<th>
					File
				</th>
			</tr>
			<tr>
				<td>
					
				</td>
				<td>
					a
				</td>
				<td>
					a
				</td>
				<td>
					a
				</td>

			</tr>
		</table>
		<br>
	</div>

	<div style="background-color:rgba(86, 56, 253, 0.9); width:60%;text-align:left;color:white">
		By Alessandro Piombini & Danilo Cavallini
		<br>
		Email:
		<ul>
			<li>
				alessandro.piombini@studio.unibo.it
			</li>
			<li>
				danilo.cavallini@studio.unibo.it
			</li>
		</ul>
		GIT repo: https://github.com/Piombo4/ISS2024-WIS
		<br>

	</div>
</body>

</html>